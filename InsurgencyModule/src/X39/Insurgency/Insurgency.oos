#include "defines.def"

using ::std::Context
using ::std::base::VehicleBase
using ::std::Man
using ::std::Vehicle
using ::std::Group

using ::GVARS
using ::X39::Insurgency::Square


namespace X39
{
	namespace Insurgency
	{
		static async void PlayerLoop()
		{
			
			while (!::GVARS::missionContext.getBool("MissionReady", false))
				sleep(1);
			auto noFilter = new array<string>();
			noFilter.pushBack("Land_HelipadEmpty_F");
			array<::X39::Insurgency::Square> currentSquaresInPool = new array<::X39::Insurgency::Square>();
			while (true)
			{
				auto player = ::std::getPlayer();
				if (SQF alive (player) as bool)
				{
					auto tmp = SQF nearestObjects(player, noFilter, ::GVARS::DespawnDistance) as array<::std::base::VehicleBase>;
					array<::X39::Insurgency::Square> handledSquares = new array<::X39::Insurgency::Square>();
					foreach (auto it in tmp)
					{
						if (::X39::Insurgency::Square::isSquare(it))
						{
							auto square = <::X39::Insurgency::Square>it.getContext().getObject("square");
							square.update();
							handledSquares.pushBack(square);
							if (!currentSquaresInPool.contains(square))
								currentSquaresInPool.pushBack(square);
						}
					}
					auto toRemove = new array<scalar>();
					for (scalar i = 0; i < currentSquaresInPool.length(); i++)
					{
						auto sq = currentSquaresInPool[i];
						if (!handledSquares.contains(sq))
						{
							if (sq.update())
							{
								toRemove.pushBack(i);
							}
						}
					}
					SQF (toRemove) sort (false);
					foreach (auto index in toRemove)
					{
						currentSquaresInPool.deleteAt(index);
					}
					
					
					//Intel pickup loop (& marker spawner)
					auto tmpFilter = new array<string>();
					tmpFilter.pushBack("Land_File1_F");
					auto arr = SQF nearestObjects (player, tmpFilter, 2) as array<::std::base::VehicleBase>;
					
					if (arr.length() > 0)
					{
						foreach (auto intel in arr)
						{
							if (intel.getContext().getBool("isIntel", false))
							{
								intel.delete();
								auto lastDistance = SQF worldSize;
								::X39::Insurgency::AmmoCache lastCache;
								foreach (auto cache in ::GVARS::AmmoCaches)
								{
									if (SQF (cache.veh) distance (player) as scalar < lastDistance)
									{
										lastDistance = SQF (cache.veh) distance (player) as scalar;
										lastCache = cache;
									}
								}
								auto markers = lastCache.getMarkers();
								scalar dstnc;
								if (markers.length() > ::GVARS::AmmoCachesIntelDistances.length())
								{
									dstnc = ::GVARS::AmmoCachesIntelDistances[::GVARS::AmmoCachesIntelDistances.length() - 1];
								}
								else
								{
									dstnc = ::GVARS::AmmoCachesIntelDistances[markers.length()];
								}
								auto marker = new ::std::Marker(SQF format("X39OBJ_%1%2", lastCache.veh.getPosition(), markers.length()) as string);
								marker.setShape(::std::Marker::Shape::Icon);
								marker.setType("mil_unknown");
								marker.setText(SQF str (dstnc));
								marker.setSize(0.5, 0.5);
								scalar xPos = random(dstnc / 2) + (dstnc / 2);
								if (random(2) > 1)
								{
									xPos = xPos * -1;
								}
								scalar yPos = random(dstnc / 2) + (dstnc / 2);
								if (random(2) > 1)
								{
									yPos = yPos * -1;
								}
								marker.setPosition(xPos, yPos);
								marker.setColor(::std::Marker::Color::ColorRed);
								marker.setAlpha(0.75);
								markers.pushBack(marker);
								lastCache.setMarkers(markers);
								auto tmpArray = new array<string>();
								tmpArray.pushBack("New intel was located!");
								tmpArray.pushBack(::BIS::textureMarker("mil_warning"));
								SQF ("IntelAdded", tmpArray) remoteExec (deref ::BIS::showNotification, true, false);
							}
						}
					}
				}
				sleep(0.5);
			}
		}
		static async void ServerLoop()
		{
			while (true)
			{
				SQF (::GVARS::missionGroup) setCombatMode ("RED");
				SQF (::GVARS::missionGroup) setBehaviour ("COMBAT");
				array<string> playerUIDs = new array<string>();
				playerUIDs.pushBack("NaN");
				auto arr = SQF allPlayers as array<::std::Man>;
				foreach (auto player in arr)
				{
					playerUIDs.pushBack(SQF getPlayerUID (player) as string);
				}
				arr = SQF allUnits as array<::std::Man>;
				foreach (auto it in arr)
				{
					string uid = it.getContext().getString("owner", "NaN");
					if (!playerUIDs.contains(uid))
					{
						it.delete();
					}
				}
				
				sleep(5);
			}
		}
	}
}