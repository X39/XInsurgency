#include "defines.def"

using ::std::Marker
using ::std::base::VehicleBase
using ::std::Man
using ::std::Group

using ::GVARS

namespace X39
{
	namespace Insurgency
	{
		static fnc array<vec3> receiveAllBuildingPositions(::std::base::VehicleBase veh)
			private ["_arr", "_i", "_ref"];
			_arr = [];
			_ref = [0, 0, 0];
			_i = 0;
			while {!((veh buildingPos _i) isEqualTo _ref)} do
			{
				_arr pushBack (veh buildingPos _i);
				_i = _i + 1;
			};
			_arr
		endFnc
		
		class Square
		{
			public ::std::Marker marker;
			public array<::std::base::VehicleBase> houses;
			public scalar housesCount;
			public ::std::Vehicle veh;
			public bool isCleared;
			
			public Square(scalar x, scalar y)
			{
				this.marker = new ::std::Marker(SQF format("X39INS_%1%2", x, y) as string);
				this.marker.setShape(::std::Marker::Shape::Rectangle);
				this.marker.setBrush(::std::Marker::Brush::Solid);
				this.marker.setType("Empty");
				this.marker.setSize(50, 50);
				this.marker.setPosition(50 + (x - mod(x, 100)), 50 + (y - mod(y, 100)));
				this.marker.setAlpha(0.75);
				this.houses = new array<::std::base::VehicleBase>();
				this.veh = new ::std::Vehicle("Land_HelipadEmpty_F", x, y, 0);
				this.veh.getContext().setBool("IsInsurgencyObject", true, true);
				this.setCleared(false);
			}
			public bool prepare()
			{
				bool hasPos = false;
				array<::std::base::VehicleBase> housesWithPos = new array<::std::base::VehicleBase>();
				foreach(auto it in this.houses)
				{
					auto var = receiveAllBuildingPositions(it);
					if(var.length() > 0)
					{
						hasPos = true;
						housesWithPos.pushBack(it);
					}
					it.getContext().setNativeObject("positions", <nobject>var, true);
				}
				////BUG: ___obj___ set [5, (___obj___) arrayIntersect (_housesWithPos)];
				//this.houses = SQF (this.houses) arrayIntersect (housesWithPos) as array<::std::base::VehicleBase>;
				auto tmpfix = SQF (this.houses) arrayIntersect (housesWithPos) as array<::std::base::VehicleBase>;
				this.houses = tmpfix;
				if(!hasPos)
				{
					this.veh.delete();
					this.marker.delete();
					return false;
				}
				auto context = this.veh.getContext();
				context.setScalar("unitCount", 0, true);
				auto tmp = new array<::std::Man>();
				this.housesCount = this.houses.length();
				
				
				foreach(auto it2 in this.houses)
				{
					it2.getContext().setObject("square", <object>this, true);
				}
				this.publish();
				return true;
			}
			
			public bool isValid()
			{
				return this.veh.getContext().getBool("isValid", false);
			}
			public void setValid(bool flag)
			{
				this.veh.getContext().setBool("isValid", flag, true);
			}
			
			public scalar getUnitCount()
			{
				return this.veh.getContext().getScalar("unitCount", 0);
			}
			public void setUnitCount(scalar i)
			{
				this.veh.getContext().setScalar("unitCount", i, true);
			}
			public void addUnitCount(scalar i)
			{
				this.setUnitCount(this.getUnitCount() + i);
			}
			
			public array<::std::Man> getLocalUnits()
			{
				auto def = new array<nobject>();
				return < array<::std::Man> >::GVARS::missionContext.getNativeObject("localUnits", <nobject>def);
			}
			public void setLocalUnits(array<::std::Man> arr)
			{
				::GVARS::missionContext.setNativeObject("localUnits", <nobject>arr, false);
			}
			public void addToLocalUnits(::std::Man man)
			{
				auto arr = this.getLocalUnits();
				arr.pushBack(man);
				this.setLocalUnits(arr);
			}
			public void removeFromLocalUnits(::std::Man man)
			{
				auto arr = this.getLocalUnits();
				scalar index = arr.find(man);
				if(index < 0)
					throw "UnitNotFound";
				arr.deleteAt(index);
				this.setLocalUnits(arr);
			}
						
			public void createUnit()
			{
				::std::base::VehicleBase house = this.houses[floor(random(this.houses.length()))];
				auto pos = < array<vec3> >house.getContext().getNativeObject("positions");
				auto unitClassName = ::GVARS::unitClasses[floor(random(::GVARS::unitClasses.length() - 1))];
				::std::Man unit = new ::std::Man(::GVARS::missionGroup, unitClassName, pos[floor(random(pos.length()))]);
				SQF doStop (unit);
				unit.getContext().setString("owner", SQF getPlayerUID (SQF player) as string, true);
				SQF (unit) addEventHandler ("Killed", "(_this select 0) setVariable ['KillTime', time, true];");
				SQF (unit) setVariable ("KillTime", -1, true);
				
				this.addUnitCount(1);
				this.addToLocalUnits(unit);
			}
			public bool update()
			{
				if (this.isCleared)
					return true;
				if (SQF (::std::Man::getPlayer()) distance (this.veh) as scalar > ::GVARS::DespawnDistance)
				{
					auto localUnits = this.getLocalUnits();
					foreach (auto v in localUnits)
					{
						v.delete();
						this.addUnitCount(-1);
					}
					this.setLocalUnits(new array<::std::Man>());
					return true;
				}
				else
				{
					auto curUnitCount = this.getUnitCount();
					scalar quota = this.housesCount * ::GVARS::HouseUnitQuota;
					if (quota > ::GVARS::MaxUnitsPerSquare)
					{
						quota = ::GVARS::MaxUnitsPerSquare;
					}
					if (curUnitCount < quota)
					{
						this.createUnit();
					}
					auto arr = this.getLocalUnits();
					bool anyAlive = false;
					foreach (auto it in arr)
					{
						if (!it.isAlive())
						{
							scalar t = SQF (it) getVariable ("KillTime", time()) as scalar;
							if (::GVARS::RespawnTimeout < (time() - t))
							{
								this.addUnitCount(-1);
								this.removeFromLocalUnits(it);
								it.delete();
								if(this.isValid())
								{
									this.createUnit();
								}
							}
						}
						else
						{
							anyAlive = true;
						}
					}
					if (!anyAlive && arr.length() > 0)
					{
						this.setCleared(true);
						return true;
					}
					return false;
				}
			}
			
			public void setCleared(bool flag)
			{
				if (flag)
				{
					this.isCleared = true;
					this.marker.setColor(::std::Marker::Color::ColorGreen);
				}
				else
				{
					this.isCleared = false;
					this.marker.setColor(::std::Marker::Color::ColorRed);
				}
			}
			
			public void publish()
			{
				auto context = this.veh.getContext();
				context.setObject("square", <object>this, true);
			}
			
			static bool isSquare(::std::base::VehicleBase vehicle)
			{
				return vehicle.getContext().getBool("IsInsurgencyObject", false);
			}
		}
	}
}